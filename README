#########################################
# Purpose: nginx install via Ansible
# Author: James Sandlin
# Date: 2015-01-19
# Contact: james@sandlininc.com
# Comments: - Ansible is not designed to be a single script for all distros. Scripts are written 
#             for a specific OS. Therefore, this script is written for CentOS 6.
#           - If you already have a /var/www/<server> webserver operating, your
#             index.htm will be replaced.
#           - You can change port number from 8080 by modifying nginx_setup.yml's port_num variable.
######################################### 

-= INITIAL SETUP REQUIRED =-
1) CentOS 6 base system setup with yum repo access.
2) <username> must have passwordless sudo on the destination server.
   Edit /etc/sudoers and add:
      <username>     ALL=(ALL)      NOPASSWD: ALL
3) ssh <username>@<server> and accept the server to your known_hosts
4) Add your <server> to the env file under the nginx role.
   Edit ${WORKSPACE}/envs/nginx
   Replace devops with your server. 
   Add as many servers as you would like, one per line.
   
-= RUN ANSIBLE =-
Call ansible-playbook -i envs/nginx tasks/nginx_setup.yml -u <username>

-= ACCESS WEBSITE =-
http://<server>:<port num>

-= ANSWERS TO QUESTIONS =-
1. Describe the most difficult/painful hurdle you had to overcome in implementing your solution.
The most difficult hurdle I had to overcome was writing the process from scratch, rather than just
reusing someone’s pre-existing role. I also had a problem accepting the simplicity of the problem. 
As I am more familiar with Ansible, I wanted to execute the task in Puppet on a Docker image. 
However, as the point of this task was to show what I am already most familiar with, I bit my tongue 
and stuck with the known. 

2. Describe which puppet related concept you think is the hardest for new users to grasp.
From my experience, the most difficult related task is not just in Puppet, but in any system 
automation tool. Old school system administrators require significant convincing regarding the 
errors which come with full manual configuration. With HHSC, I was continuously having to discuss 
automation with the head of the WebSphere admins when I was implementing RAFW (Rational Automation 
Framework for WebSphere). His opinion was that the more things are automated, the less his team 
members would understand how to fix problems when they arise. "As long as all nodes are maintained 
manually and all web services are deployed manually, the admin doing the deployments knows how to 
resolve problems.” My response was simple: If we automate creation of a server, container, or 
WebSphere node, team members can spend time making things run more streamlined, rather than spending 
their time executing the same tasks repetitively.
 
3. Please comment on the concept embodied by the second requirement of the solution(ii)
Sticking with this task: I should not need multiple scripts to deploy a website. What if I execute 
this solution then realize the html is not complete? If the script could not be rerun, I would need 
a fully separate script or more complicated logic for updating the web contents file. By ensuring I 
can rerun the script repetitively (one of Ansible’s benefits) and only affect changed portions, I can 
use this same script for setting up a web server from scratch or just to deploy an updated html file.

4. Where did you go to find information to help you in the build process?
Having used Ansible prior, I referenced scripts I have in my library. I also used docs.ansible.com 
for anything I couldn’t find in my library.

5. In a couple paragraphs explain what automation means to you and why it is important to an 
organization's infrastructure design strategy
Automation is the toolset which delivers product deployment and infrastructure management to the 
next level. Prior to automation, a project would have a set number of servers to be shared by all 
personal. These servers were strictly managed by the IT team and access granted to others was 
significantly limited. When a developer did get admin access to a server, if anything was done to 
harm the environment, everyone depending on it would be dead in the water. This was a common occurrence 
and on large projects caused the need of dedicated individuals who just handled change management 
across environments and releases.

Enter automation and a significant portion of this effort is no longer in day to day management, rather 
the automation thereof. And with this automation, environments are given the benefit which the assembly 
line provided to production. Rather than a single individual producing a single product over a long period 
of time, automation can be used to create environments or maintain large numbers of environments very quickly. 
Pair this with virtualization and rather than the limited number of large environments used across teams, 
we can automate a large number of limited size environments so teams do not interfere with one another’s work. 
Not only do we have the benefit of speed; automation also provides a significant improvement on change and 
environment management. Rather than having humans who are ensuring environment changes, configuration changes, 
and code changes are deployed in sync with one another, everything is automated and developed in parallel. 
Therefore, when a new version of code is deployed into an environment, the corresponding environment 
automation can ensure things run as expected.

With clustered web services running hundreds of instances, the days of manually handling server setup and 
product deployment are fading. As mentioned prior, anyone who attempts to execute the same change multiple 
times manually is going to make a mistake. Automation not only speeds up the propagation and configuration of 
servers but it also ensures things are done correctly.

